= pod 

=head2 AnyEventX-CondVar

B<! This module is work in progress. The code is likely to change !>

Condition variables represent a promise of delivering a result
sometime in the future. They are used in event loop frameworks such
as L<AnyEvent> to define the execution flow of an asynchronous
program. However, making extensive use of condition variables tends to
create callback-embedded code where the execution I<continuation> of
your program is hard to follow. 

L<AnyEventX::CondVar> tries to fix that by providing a simple interface
to L<AnyEvent::CondVar|AnyEvent> that produces flat and readable code.
Let's start off with an example. Assume we have access to a database
API C<$db> that produces C<AnyEvent::CondVar> objects in the first
case and C<AnyEventX::CondVar> objects in the second case.

    use AnyEvent;

    sub get_keys {
        my @keys = @_;

        my @results
        $cv = AnyEvent->condvar;

        $cv->begin( sub {
            shift->send( @results );
        });

        foreach my $i ( 0..$#keys ) {
            $cv->begin;
            $db->get( $keys[$i] )->cb( sub {
                results[$i] = shift->recv;
                cv->end;
            });
        }

        $cv->end;
        $cv;
    }

Now here is how you would write the piece of code with
C<AnyEventX::CondVar>:

    use AnyEventX::CondVar;

    sub get_keys {
        cv( @_ )->map( sub { $db->get( $_ ) } );
    }

The difference in both examples is the descriptive power of the
library. It's not straightforward in the first example what that code
does. You need to parse it in your head, and the execution flow is not
linear ( the C<begin> callback at the top is executed at the end ). In
the second example, it is quite clear (to me) that we want to map all
the input elements to database calls, but I'll let you be the judge of
that.

Before reading on, if you are unfamiliar with AnyEvent condition
variables, I suggest you go through the L<AnyEvent> documentation for
more information on the scope of this library.

=head2 Philosophy

Condition variables are great values to return from asynchronous APIs.
They represent a promise of delivering a result, or a condition to
become true. It also allows the users of your API to decide whether
they should block or not. As an API provider, this decision is quite
simple: you should never block the user program in your code.

Essentially, asynchronous APIs are composed of the following steps:

=over

=item *

Asynchronous operations ( HTTP, Database )

=item *

Data transformations

=item *

Return a condition variable or execute a user callback

=back

Traditionally, you would handle data transformations from asynchronous
operations inside callbacks to prevent blocking the user program. This
library simplifies the process of data transformations by operating
directly on the condition variables. You can imagine this library as
applying transformations on future values. When I write this:

    $db->get( $a )->cons( $db->get( $b ) )

I am basically fetching $a and $b in parallel and returning a
condition variable that will contain the concatenation of both
results. The concatenation obviously only happens once the actual
database values are available but this doesn't prevent me from
describing this operations in advance. Here, I am giving to the user a
promise to deliver two concatenated values. 

Essentially, this library allows you to apply transformations on
promises :)

=head2 Synopsis

We assume we have access to a C<$db> API that produces
C<AnyEventX::CondVar> objects. Every call to a C<AnyEventX::CondVar>
method returns a new C<AnyEventX::CondVar> for chaining calls.

    use AnyEventX::CondVar;

    # Perl basic operator overload
    # + - * / % ** << >> x . 
    # < <= > >= == !=
    # <=> cmp lt le gt ge eq ne
    # & | ^ ~~
    $cv = $db->get( 'id' ) + 1;

    # Perl unary operator overload
    # neg ! ~
    # atan2 cos sin exp abs log sqrt int
    $cv = cos $db->get( 'angle' );

    # Concatenation, Append and Continuation
    $db->get( $a )
        ->cons( $db->get( $b ) )
        ->append( $db->get( $c ), $db->get( $d ) )
        ->then( sub {
            my @values = @_;
            ...
        });

    # List Operations
    $db->get( $a )
        ->push( $db->get( $b ), $db->get( $c ) )
        ->pop
        ->unshift( $db->get( $d ), $db->get( $e ) )
        ->shift;

    # Get/Set List elements
    $db->get( @keys )
        ->aset( 2 => $a )
        ->aget( 2 )
        ->first
        ->last;

    # Get/Set Hash elements
    $db->get( @keys )
        ->hget( 'a', 'b' ) # Get one or more keys
        ->hset( a => 3 );

    # Advanced List Operations
    $db->get( @keys )
        ->map( sub { $_ * 2 } )
        ->grep( sub { $_ % 2 } )
        ->sort( sub { $a cmp $b } )
        ->reduce( sub { $a + $b }, 0 ) # second param is accumulator
        ->unique( sub { $_->id } )
        ->sum
        ->mul;

    # Boolean Operations
    ( $db->get( 'a' ) >= 3 )
        ->and( sub { ... } ); # Executed if condvar is true

    ( $db->get( 'a' ) >= 3 )
        ->or( sub { ... } ); # Executed if condvar is false

    # Stash temporary results
    $db->get( @keys )
        ->push_stash # Remember the condvar value here
        ->map( sub { ... } ) 
        ->pop_stash; # Pop the stash

    # MISC Operators

    $db->get( $a )
        ->deref # Dereference underlying value
        ->wait( 0.1 )
        ->result( $db->get( $b ) ); # Replace condvar value

    $db->get( $a )
        ->any( $db->get( $b ) ) # Returns first async result
        ->any( $db->get( $c ) )
        ->then( sub {
            my $quickest = shift; # Value of $a, $b or $c
            ...
        });

    # Helpers to build AnyEventX::CondVar

    # Builds an AnyEventX CV that returns immediately.
    # Useful to access the underlying API
    cv( $scalar ); 
    cv( @list ); 
    cv( %hash ); 

    # Builds a AnyEventX CV from a chain of callbacks
    cv_build {
        $redis->hget( $key => $value => $_ );
    } cv_then {
        my ( $redis, $value ) = @_;
        $redis->hset( $key => $value + 1 );
    }

    # Build a AnyEventX CV that waits
    cv_wait( 0.1 )

=head2 How to use

A condition variable contains the promise of delivering a result. That
result can be either a scalar, an array or a hash. Transformations of
that result can be performed by chaining method calls. Internally,
each call appends a callback to the condition which will be applied to
the result when it becomes available. A method call will also return a
new condition variable that essentially promises to deliver the
transformed result when it becomes available. This way, you can chain
transformations together easily as such:

    $db->get( @keys )
        ->map( sub { ... } )
        ->grep( sub { ... } );

One of the most powerful operations is C<then>. It allows you to
specify the continuation of a condition variable. It is useful for
providing merge points of parallel executions such as:

    $db->get( 'a' )->cons( $db->get( 'b' ) )
        ->then( sub {
            my ( $a, $b ) = @_;
            # Do stuff with $a and $b
            ( $a2, $b2 );
        });

You can also think of C<then> as providing a way of handling
asynchronous data dependencies. C<then> is used internally to
implement most of this library's API.

=head2 Bugs

Please report any bugs in the projects bug tracker:

L<http://github.com/ciphermonk/AnyEventX-CondVar/issues>

You can also provide a fix by contributing to the project:

=head2 Contributing

We're glad you want to contribute! It's simple:

=over

=item * 
Fork the project

=item *
Create a branch C<git checkout -b my_branch>

=item *
Commit your changes C<git commit -am 'comments'>

=item *
Push the branch C<git push origin my_branch>

=item *
Open a pull request

=back

=head2 Supporting

Like what you see? You can support the project by donating in
L<Bitcoins|http://www.weusecoins.com/> to:

B<17YWBJUHaiLjZWaCyPwcV8CJDpfoFzc8Gi>

=head2 Copyright and license

Copyright (C) 2012 ciphermonk

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see L<http://www.gnu.org/licenses/>

=cut


