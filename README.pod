= pod 

=head2 AnyEventX-CondVar

B<! This module is work in progress. The code is likely to change. And
the documentation as well !>

AnyEventX-CondVar is a wrapper module around L<AnyEvent> condition
variables. It's purpose is to provide a clean and readible API for
manipulating condition variables. This is achieved by extending the
L<AnyEvent::CondVar|AnyEvent> library with chainable transformations.

Condition variables are promises of delivering results. They are used
in asynchronous frameworks as an alternative to callbacks and for
synchronizing parallel execution flows. I recommend reading the
L<AnyEvent> documentation on condition variables if you are not
already familiar with them.

Returning condition variables from asynchronous API's is generally
more flexible than requirering callbacks as users can decide to block
or not on API calls. The downside of building complex operations with
condition variables is code readability. It's easy to end up with
embedded callback code and spaghetti flows of execution. This library
is an attempt at solving these issues and make it easy and fun to code
with condition variables. I hope you find it useful!

Let's start with an example. Given a list of C<@keys>, we want to
retrieve the database values for each key in parallel and return the
result as a C<%hash> ( in a condition variable ).  Let's assume we
have access to a database API C<$db> that produces AnyEvent (old) and
AnyEventX (new) condition variables. Here is how you would solve this
problem traditionally:

    use AnyEvent;

    sub get_keys {
        my @keys = @_;

        my %results
        my $cv = AnyEvent->condvar;

        $cv->begin( sub {
            shift->send( %results );
        });

        foreach my $key ( @keys ) { 
            $cv->begin;
            $db->get( $key )->cb( sub {
                results{ $key } = shift->recv;
                cv->end;
            });
        }

        $cv->end;
        $cv;
    }

And using the C<AnyEventX::CondVar> approach:

    use AnyEventX::CondVar;

    sub get_keys {
        cv( @_ )->map( sub { 
            $_ => $db->get( $_ )
        });
    }

Power comes from conciseness, all other things being equal.

=head2 Design philosophy

We believe that returning condition variables from asynchronous API's
is more powerful than requesting callbacks from users for the
following reasons:

=over

=item *

You save yourself an argument in your function calls

=item *

You return meaningful values from your asynchronous functions

=item *

Your API can be used in a blocking or non-blocking fashion

=back

Building asynchronous APIs then boils down to:

=over

=item *

Performing asynchronous operations ( HTTP, Database )

=item *

Applying data transformations and

=item *

Returning them through a condition variable.

=back

Our goal is to make the data transformations as clear and effective as
possible. We claim that in most cases, it is not necessary to leave
the realm of condition variables to describe data transformations.  It
is somewhat wasteful to "peek" into condition variables and build
new ones for simple transformations.

    use AnyEvent;

    sub penguins {
        my $cv = AnyEvent->condvar;

        $db->get( 'zoo_animals' )->cb( sub {
            my @animals = shift->recv;
            $cv->send( grep { $_->type eq 'penguin' } );
        });

        $cv;
    }

The above example could be more concisely describe as follows:

    use AnyEventX::CondVar;

    sub penguins {
        $db->get( 'zoo_animals' )
            ->grep( sub { $_->type eq 'penguin' } );
    }

Using the second form saves you from writing a lot of boilerplate code
that can be automatically generated for you. Both examples above are
functionally identical. This example holds for many list
transformations such as C<map>, C<sort> and C<reduce>.

Somethine else you might be doing a lot when writing asynchronous code
is performing parallel operations with merge-point callbacks.

    use AnyEvent;

    my $cv = AnyEvent->condvar;

    my ( $roy, $silo );

    $cv->begin;
    $db->get( 'roy' )->cb( sub { $roy = shift->recv; $cv->end; } );

    $cv->begin;
    $db->get( 'silo' )->cb( sub { $silo = shift->recv; $cv->end; } );

    $cv->cb( sub {
        # Do stuff with roy and silo. Be gentle !
    });

We provide two powerful constructs for dealing with this problem:
C<cons> and C<then> for concatenating condition variables and dealing
with data dependencies.

    use AnyEvent::CondVar;

    $db->get( 'roy' )->cons( $db->get( 'silo' ) )
        ->then( sub {
            my ( $roy, $silo ) = @_;
            # Do stuff with roy and silo. Be nice !
        });

From the example above, you can notice that calls such as C<cons> and
C<then> can be chained. This holds true for every method in this
library. Every call produces a new condition variable holding the
result of the previous transformation. 

=head2 Advanced usage

C<then> is probably the most powerful call as it is used internally to
implement most of the API. C<then> produces a new condition variable
that holds the return value of your callback. If your callback returns
a condition variable, C<then> will link it to it's own condition
variable. This allows for powerful chaining of condition variables
with data dependencies:

    use AnyEvent::CondVar;

    $db->get( 'roy' )->cons( $db->get( 'silo' ) )
        ->then( sub {
            my ( $roy, $silo ) = @_;
            $_->birthday for (( $roy, $silo ));
            $db->set( $roy )->cons( $db->set( $silo ) ); 
        })
        ->then( sub {
            my ( $roy, $silo ) = @_;
            # We're done saving. Continue here ... 
        });

C<then> even allows you to return a mix of condition variables and
traditional scalars in a list. It will produce a new condition
variable holding the concatenation of all the returned values. It does
the right thing as expected:

    use AnyEvent::CondVar;

    $db->get( 'roy' )->cons( $db->get( 'silo' ) )
        ->then( sub {
            my ( $roy, $silo ) = @_;
            $_->birthday for (( $roy, $silo ));
            ( 
                $db->set( $roy ), # Condvar
                $db->set( $silo ), # Condvar
                $roy->age, #Scalar
                $silo->age, #Scalar
            ); 
        })
        ->then( sub {
            my ( $roy, $silo, $roy_age, $silo_age ) = @_;
            # We're done saving. Continue here ... 
        });

This powerful feature is available in most calls of this API. Let's
take the first C<map> example again from the top of the page:

    use AnyEventX::CondVar;

    sub get_keys {
        cv( @_ )->map( sub { 
            $_ => $db->get( $_ )
        });
    }

This map transforms the keys into condition variables generated by
C<$db>.  Because C<map> is implemented internally using C<then>, it
returns a condition variable that will hold the concatenation of all
the database results. You could provide a continuation to this map to
handle the results once they are available:

    cv( @_ )->map( sub { 
        $_ => $db->get( $_ )
    })->then( sub {
        my %results = @_;
        # Do stuff with the %results
    })

=head2 More please !

For a complete and exhaustive documentation of the library, head over
to the wiki ! ( TODO ... )

=head2 Bugs

Please report any bugs in the projects bug tracker:

L<http://github.com/ciphermonk/AnyEventX-CondVar/issues>

You can also provide a fix by contributing to the project:

=head2 Contributing

We're glad you want to contribute! It's simple:

=over

=item * 
Fork the project

=item *
Create a branch C<git checkout -b my_branch>

=item *
Commit your changes C<git commit -am 'comments'>

=item *
Push the branch C<git push origin my_branch>

=item *
Open a pull request

=back

=head2 Supporting

Like what you see? You can support the project by donating in
L<Bitcoins|http://www.weusecoins.com/> to:

B<17YWBJUHaiLjZWaCyPwcV8CJDpfoFzc8Gi>

=head2 Copyright and license

Copyright (C) 2012 ciphermonk

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see L<http://www.gnu.org/licenses/>

=cut


